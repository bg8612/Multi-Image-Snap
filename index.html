<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Точная Печать Изображений</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React and Babel for JSX compilation -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script> 
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <style>
        html { font-family: 'Inter', sans-serif; }
        
        /* Стили для печати - КРИТИЧЕСКИ ВАЖНО для точности */
        @page {
          size: A4;
          margin: 0;
        }
        @media print {
          html, body {
            height: 100%;
            margin: 0 !important;
            padding: 0 !important;
            overflow: visible !important;
            -webkit-print-color-adjust: exact !important; 
            color-adjust: exact !important;
          }
          body * {
            visibility: hidden;
          }
          #printable-area, #printable-area * {
            visibility: visible;
          }
          #printable-area {
            position: fixed !important;
            left: 0 !important;
            top: 0 !important;
            width: 210mm !important;
            height: 297mm !important;
            z-index: 9999 !important;
            background: white !important;
            box-shadow: none !important;
            margin: 0 !important;
            border: none !important;
            outline: none !important;
            transform: none !important;
          }
          .no-print {
            display: none !important;
          }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        // --- Иконки (SVG заглушки) ---
        const Icon = ({ children, className = 'w-5 h-5', color = 'currentColor' }) => (
            <svg className={className} fill="none" stroke={color} viewBox="0 0 24 24" 
                xmlns="http://www.w3.org/2000/svg" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                {children}
            </svg>
        );

        const Upload = (props) => (
            <Icon {...props}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></Icon>
        );
        const Printer = (props) => (
            <Icon {...props}><polyline points="6 9 6 2 18 2 18 9"></polyline><path d="M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2"></path><rect x="6" y="14" width="12" height="8"></rect></Icon>
        );
        const Move = (props) => (
            <Icon {...props}><polyline points="5 9 2 12 5 15"></polyline><polyline points="9 5 12 2 15 5"></polyline><polyline points="15 19 12 22 9 19"></polyline><polyline points="19 15 22 12 19 9"></polyline><line x1="2" y1="12" x2="22" y2="12"></line><line x1="12" y1="2" x2="12" y2="22"></line></Icon>
        );
        const AlertTriangle = (props) => (
            <Icon {...props}><path d="M10.29 3.86L1.86 18a2 2 0 0 0 1.74 3h16.8a2 2 0 0 0 1.74-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line></Icon>
        );
        const Ruler = (props) => (
            <Icon {...props}><path d="M6 21l-4-4L15 2l4 4z"></path><path d="M13.5 10.5l4-4"></path><path d="M12.5 14.5l4-4"></path><path d="M11.5 18.5l4-4"></path><path d="M8.5 19.5l4-4"></path></Icon>
        );
        const CheckCircle = (props) => (
            <Icon {...props}><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline></Icon>
        );
        const Search = (props) => (
            <Icon {...props}><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></Icon>
        );
        const Settings = (props) => (
            <Icon {...props}><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 0-2 0l-.15-.08a2 2 0 0 0-2.73 2.73l.08.15a2 2 0 0 0 0 2l-.25.43a2 2 0 0 1-1.73 1v.44a2 2 0 0 0 2 2h.18a2 2 0 0 1 1.73 1l.25.43a2 2 0 0 0 0 2l-.08.15a2 2 0 0 0 2.73 2.73l.15-.08a2 2 0 0 0 2 0l.43-.25a2 2 0 0 1 1.73-1V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 0 2 0l.15.08a2 2 0 0 0 2.73-2.73l-.08-.15a2 2 0 0 0 0-2l.25-.43a2 2 0 0 1 1.73-1v-.44a2 2 0 0 0-2-2h-.18a2 2 0 0 1-1.73-1l-.25-.43a2 2 0 0 0 0-2l.08-.15a2 2 0 0 0-2.73-2.73l-.15.08a2 2 0 0 0-2 0l-.43.25a2 2 0 0 1-1.73-1V4a2 2 0 0 0-2-2z"></path><circle cx="12" cy="12" r="3"></circle></Icon>
        );
        const Crosshair = (props) => (
            <Icon {...props}><circle cx="12" cy="12" r="10"></circle><line x1="22" y1="12" x2="18" y2="12"></line><line x1="6" y1="12" x2="2" y2="12"></line><line x1="12" y1="6" x2="12" y2="2"></line><line x1="12" y1="22" x2="12" y2="18"></line></Icon>
        );
        const ArrowUpLeft = (props) => (
            <Icon {...props}><line x1="17" y1="17" x2="7" y2="7"></line><polyline points="7 17 7 7 17 7"></polyline></Icon>
        );
        const Trash2 = (props) => (
            <Icon {...props}><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></Icon>
        );
        const Plus = (props) => (
            <Icon {...props}><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></Icon>
        );
        const Magnet = (props) => (
            <Icon {...props}><path d="M6 15v-5a6 6 0 1 1 12 0v5"></path><path d="M6 15h4v4H6z"></path><path d="M14 15h4v4h-4z"></path></Icon>
        );


        const { useState, useRef, useEffect, useMemo } = React;
        const ReactDOMClient = ReactDOM;

        const A4_WIDTH_MM = 210;
        const A4_HEIGHT_MM = 297;
        const GRID_SIZE_MM = 10;
        const SNAP_THRESHOLD_MM = 3; // Дистанция срабатывания магнита

        function App() {
          // --- State ---
          const [images, setImages] = useState([]); // Массив объектов изображений
          const [selectedId, setSelectedId] = useState(null); // ID выбранного изображения
          
          // Временное хранение ввода для активного изображения
          const [widthInput, setWidthInput] = useState('');
          const [heightInput, setHeightInput] = useState('');
          
          const [isDragging, setIsDragging] = useState(false);
          const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });
          
          const [showGrid, setShowGrid] = useState(true);
          const [isSnapping, setIsSnapping] = useState(true); // Включено ли прилипание
          
          const [isOutOfBounds, setIsOutOfBounds] = useState(false);
          
          const [printerName, setPrinterName] = useState('');
          const [isPrinterConnected, setIsPrinterConnected] = useState(false);
          const [isSearchingPrinter, setIsSearchingPrinter] = useState(false);

          const [message, setMessage] = useState(null);
          const [confirmingOut, setConfirmingOut] = useState(false);

          const paperRef = useRef(null);

          // Получаем активный объект изображения
          const selectedImage = useMemo(() => 
            images.find(img => img.id === selectedId), 
            [images, selectedId]
          );

          // Синхронизация инпутов при смене выделенного изображения
          useEffect(() => {
            if (selectedImage) {
              setWidthInput(selectedImage.width.toString());
              setHeightInput(selectedImage.height.toString());
            } else {
              setWidthInput('');
              setHeightInput('');
            }
          }, [selectedId, selectedImage?.width, selectedImage?.height]); // зависим от размеров в store, если они поменялись извне

          // Проверка выхода за границы (для всех или только выбранного?)
          // Будем проверять выбранное, или "хотя бы одно" перед печатью.
          // Для UI проверяем выбранное.
          useEffect(() => {
            if (!selectedImage) {
              setIsOutOfBounds(false);
              return;
            }
            const { x, y, width, height } = selectedImage;
            const isOut = x < 0 || y < 0 || (x + width) > A4_WIDTH_MM || (y + height) > A4_HEIGHT_MM;
            setIsOutOfBounds(isOut);
          }, [selectedImage]);

          // --- Handlers ---

          const handleImageUpload = (e) => {
            const file = e.target.files[0];
            if (file) {
              const reader = new FileReader();
              reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                  const ratio = img.width / img.height;
                  
                  // Стандартный размер при загрузке: 100мм ширина
                  const startW = 100;
                  const startH = parseFloat((startW / ratio).toFixed(1));
                  
                  const newImage = {
                    id: Date.now(), // Уникальный ID
                    src: event.target.result,
                    width: startW,
                    height: startH,
                    x: (A4_WIDTH_MM - startW) / 2, // Центрируем
                    y: (A4_HEIGHT_MM - startH) / 2,
                    ratio: ratio,
                    maintainAspectRatio: true,
                  };
                  
                  setImages(prev => [...prev, newImage]);
                  setSelectedId(newImage.id); // Выбираем новое
                };
                img.src = event.target.result;
              };
              reader.readAsDataURL(file);
              // Сброс инпута чтобы можно было загрузить тот же файл
              e.target.value = '';
            }
          };

          const updateSelectedImage = (updates) => {
            if (!selectedId) return;
            setImages(prev => prev.map(img => 
              img.id === selectedId ? { ...img, ...updates } : img
            ));
          };

          const deleteSelectedImage = () => {
             if(!selectedId) return;
             setImages(prev => prev.filter(img => img.id !== selectedId));
             setSelectedId(null);
          };

          const centerSelectedImage = () => {
            if (!selectedImage) return;
            updateSelectedImage({
              x: (A4_WIDTH_MM - selectedImage.width) / 2,
              y: (A4_HEIGHT_MM - selectedImage.height) / 2
            });
          };

          const setTopLeftSelectedImage = () => {
             updateSelectedImage({ x: 10, y: 10 });
          };

          // Изменение размеров через инпуты
          const handleWidthChange = (val) => {
            setWidthInput(val);
            const w = parseFloat(val);
            if (!selectedImage || isNaN(w)) return;

            const updates = { width: w };
            if (selectedImage.maintainAspectRatio) {
              updates.height = parseFloat((w / selectedImage.ratio).toFixed(1));
              setHeightInput(updates.height.toString()); // обновляем инпут высоты сразу
            }
            updateSelectedImage(updates);
          };

          const handleHeightChange = (val) => {
            setHeightInput(val);
            const h = parseFloat(val);
            if (!selectedImage || isNaN(h)) return;

            const updates = { height: h };
            if (selectedImage.maintainAspectRatio) {
              updates.width = parseFloat((h * selectedImage.ratio).toFixed(1));
              setWidthInput(updates.width.toString());
            }
            updateSelectedImage(updates);
          };

          // --- Drag & Snap Logic ---

          const startDrag = (clientX, clientY, id) => {
            setSelectedId(id); // Выбираем то, что тянем
            
            // Перемещаем в конец массива (чтобы было сверху)
            setImages(prev => {
                const img = prev.find(i => i.id === id);
                const others = prev.filter(i => i.id !== id);
                return [...others, img];
            });

            setIsDragging(true);
            
            // Находим координаты текущего элемента
            const currentImg = images.find(i => i.id === id);
            if (!currentImg) return;

            const paperRect = paperRef.current.getBoundingClientRect();
            const pixelsPerMm = paperRect.width / A4_WIDTH_MM;

            const mouseXMm = (clientX - paperRect.left) / pixelsPerMm;
            const mouseYMm = (clientY - paperRect.top) / pixelsPerMm;

            setDragOffset({
              x: mouseXMm - currentImg.x,
              y: mouseYMm - currentImg.y
            });
          };

          const handleMouseDown = (e, id) => {
            e.preventDefault(); 
            e.stopPropagation();
            startDrag(e.clientX, e.clientY, id);
          };

          const handleTouchStart = (e, id) => {
             e.stopPropagation();
             const touch = e.touches[0];
             startDrag(touch.clientX, touch.clientY, id);
          };

          // Функция примагничивания (Snap)
          const snapToGrid = (value) => {
            if (!isSnapping) return value;
            
            // Ближайшая линия сетки
            const nearestGridLine = Math.round(value / GRID_SIZE_MM) * GRID_SIZE_MM;
            
            // Если расстояние меньше порога - магнитим
            if (Math.abs(value - nearestGridLine) < SNAP_THRESHOLD_MM) {
                return nearestGridLine;
            }
            return value;
          };

          useEffect(() => {
            const moveDrag = (clientX, clientY) => {
              if (!isDragging || !selectedId) return;
              
              const paperRect = paperRef.current.getBoundingClientRect();
              if (!paperRect.width) return;
              const pixelsPerMm = paperRect.width / A4_WIDTH_MM;

              let rawX = ((clientX - paperRect.left) / pixelsPerMm) - dragOffset.x;
              let rawY = ((clientY - paperRect.top) / pixelsPerMm) - dragOffset.y;
              
              // Применяем магнит к координатам (левый верхний угол)
              let newX = snapToGrid(rawX);
              let newY = snapToGrid(rawY);

              // Округляем до 0.1 мм (если не сработал магнит, чтобы не было кучи знаков)
              if (newX === rawX) newX = Math.round(newX * 10) / 10;
              if (newY === rawY) newY = Math.round(newY * 10) / 10;

              // Обновляем состояние
              setImages(prev => prev.map(img => 
                img.id === selectedId ? { ...img, x: newX, y: newY } : img
              ));
            };

            const handleMouseMove = (e) => moveDrag(e.clientX, e.clientY);
            const handleTouchMove = (e) => {
               if(isDragging) e.preventDefault();
               moveDrag(e.touches[0].clientX, e.touches[0].clientY);
            };

            const handleEnd = () => setIsDragging(false);

            if (isDragging) {
              window.addEventListener('mousemove', handleMouseMove);
              window.addEventListener('mouseup', handleEnd);
              window.addEventListener('touchmove', handleTouchMove, { passive: false });
              window.addEventListener('touchend', handleEnd);
            }

            return () => {
              window.removeEventListener('mousemove', handleMouseMove);
              window.removeEventListener('mouseup', handleEnd);
              window.removeEventListener('touchmove', handleTouchMove);
              window.removeEventListener('touchend', handleEnd);
            };
          }, [isDragging, dragOffset, selectedId, isSnapping]); // Добавил isSnapping в зависимости

          // --- Printer Logic ---
          const findPrinter = () => {
            setIsSearchingPrinter(true);
            setTimeout(() => {
              setIsSearchingPrinter(false);
              if (!printerName) setPrinterName('Системный принтер (по умолчанию)');
              setIsPrinterConnected(true);
            }, 1500);
          };

          const executePrint = () => {
            window.focus();
            setTimeout(() => {
                window.print();
            }, 100);
            setConfirmingOut(false);
            setMessage(null);
          }

          const handlePrint = () => {
            if (!isPrinterConnected) {
              setMessage({ type: 'error', text: "Подключите принтер перед печатью." });
              return;
            }
            
            // Проверяем, есть ли хоть одна картинка вне границ
            const anyOutOfBounds = images.some(img => 
                img.x < 0 || img.y < 0 || (img.x + img.width) > A4_WIDTH_MM || (img.y + img.height) > A4_HEIGHT_MM
            );

            if (anyOutOfBounds) {
              setConfirmingOut(true);
              return;
            }

            executePrint();
          };

          // --- Компоненты UI ---
          const MessageComponent = ({ message, onClose }) => (
            <div className={`fixed top-4 right-4 z-50 p-4 rounded-lg shadow-xl transition-opacity duration-300 ${message.type === 'error' ? 'bg-red-100 border-red-400 text-red-700' : 'bg-green-100 border-green-400 text-green-700'}`}>
                <div className="flex justify-between items-center">
                    <span className="font-semibold">{message.text}</span>
                    <button onClick={onClose} className="ml-4 text-gray-500 hover:text-gray-700">&times;</button>
                </div>
            </div>
          );

          const ConfirmationModal = ({ onConfirm, onCancel }) => (
            <div className="fixed inset-0 bg-black/50 z-50 flex items-center justify-center p-4">
              <div className="bg-white rounded-xl shadow-2xl p-6 w-full max-w-sm space-y-4">
                <h3 className="text-xl font-bold text-red-600 flex items-center gap-2">
                    <AlertTriangle className="w-5 h-5" /> Внимание
                </h3>
                <p className="text-gray-700">Некоторые изображения выходят за границы листа и будут обрезаны.</p>
                <div className="flex justify-end gap-3 pt-2">
                    <button onClick={onCancel} className="px-4 py-2 text-sm font-medium border border-gray-300 rounded-lg text-gray-700 hover:bg-gray-100">Отмена</button>
                    <button onClick={onConfirm} className="px-4 py-2 text-sm font-medium bg-red-600 text-white rounded-lg hover:bg-red-700">Печать</button>
                </div>
              </div>
            </div>
          );

          return (
            <div className="min-h-screen bg-gray-100 flex flex-col md:flex-row text-slate-800 font-sans">
              
              {message && <MessageComponent message={message} onClose={() => setMessage(null)} />}
              {confirmingOut && <ConfirmationModal onConfirm={executePrint} onCancel={() => setConfirmingOut(false)} />}

              {/* Левая панель */}
              <div className="w-full md:w-80 bg-white shadow-xl p-6 z-10 flex flex-col gap-5 overflow-y-auto h-auto md:h-screen print:hidden">
                <div>
                  <h1 className="text-2xl font-bold text-blue-600 flex items-center gap-2">
                    <Printer className="w-6 h-6" /> Точная Печать
                  </h1>
                  <p className="text-xs text-gray-500 mt-1">Multi-Image & Snap</p>
                </div>

                {/* Блок Принтера */}
                <div className="bg-slate-50 p-4 rounded-lg border border-slate-200 shadow-sm">
                  <h3 className="font-semibold text-gray-700 flex items-center gap-2 mb-3 text-sm">
                    <Settings className="w-4 h-4" /> Настройка Принтера
                  </h3>
                  {!isPrinterConnected ? (
                    <div className="space-y-3">
                      <input type="text" placeholder="Модель принтера" value={printerName} onChange={(e) => setPrinterName(e.target.value)} className="w-full border rounded px-2 py-2 text-sm focus:ring-2 focus:ring-blue-500 outline-none" />
                      <button onClick={findPrinter} disabled={isSearchingPrinter} className="w-full py-2 bg-slate-800 text-white rounded text-sm font-medium hover:bg-slate-700 transition flex items-center justify-center gap-2">
                        {isSearchingPrinter ? <span className="animate-spin rounded-full h-3 w-3 border-b-2 border-white"></span> : <><Search className="w-3 h-3" /> Найти</>}
                      </button>
                    </div>
                  ) : (
                    <div className="bg-green-50 border border-green-200 rounded p-3">
                      <div className="flex items-center gap-2 text-green-700 font-medium text-sm"><CheckCircle className="w-4 h-4" /> <span>Готов</span></div>
                      <div className="text-xs text-gray-600 mt-1 pl-6">Модель: <strong>{printerName}</strong></div>
                    </div>
                  )}
                </div>

                <hr className="border-gray-100" />

                {/* Загрузка */}
                <div className="flex flex-col gap-2">
                    <label className="flex items-center justify-center gap-2 w-full py-3 border-2 border-dashed border-blue-300 bg-blue-50 text-blue-700 rounded-lg cursor-pointer hover:bg-blue-100 transition">
                        <input type="file" accept="image/*" onChange={handleImageUpload} className="hidden" />
                        <Plus className="w-5 h-5" />
                        <span className="font-medium text-sm">Добавить изображение</span>
                    </label>
                    <p className="text-xs text-gray-400 text-center">Можно добавить несколько</p>
                </div>

                {/* Настройки выбранного изображения */}
                {selectedImage ? (
                  <div className="space-y-4 bg-gray-50 p-3 rounded-lg border border-gray-200">
                    <div className="flex items-center justify-between">
                      <h3 className="font-semibold text-gray-700 flex items-center gap-2 text-sm">
                        <Ruler className="w-4 h-4" /> Выбранное:
                      </h3>
                      <button onClick={deleteSelectedImage} className="text-red-500 hover:text-red-700 p-1 rounded hover:bg-red-100 transition" title="Удалить">
                        <Trash2 className="w-4 h-4" />
                      </button>
                    </div>

                    <div className="flex gap-1 justify-between">
                         <button onClick={setTopLeftSelectedImage} className="text-xs bg-white border hover:bg-gray-100 px-2 py-1 rounded flex items-center gap-1 shadow-sm" title="В угол (10мм)">
                            <ArrowUpLeft className="w-3 h-3" /> Лев.верх
                         </button>
                         <button onClick={centerSelectedImage} className="text-xs bg-white border hover:bg-gray-100 px-2 py-1 rounded flex items-center gap-1 shadow-sm" title="В центр">
                            <Crosshair className="w-3 h-3" /> Центр
                         </button>
                    </div>
                    
                    <div className="grid grid-cols-2 gap-3">
                      <div>
                        <label className="text-xs text-gray-500 block mb-1">Ширина (мм)</label>
                        <input type="number" value={widthInput} onChange={(e) => handleWidthChange(e.target.value)} className="w-full border rounded px-2 py-1 focus:ring-2 focus:ring-blue-500 outline-none" step="0.1" />
                      </div>
                      <div>
                        <label className="text-xs text-gray-500 block mb-1">Высота (мм)</label>
                        <input type="number" value={heightInput} onChange={(e) => handleHeightChange(e.target.value)} className="w-full border rounded px-2 py-1 focus:ring-2 focus:ring-blue-500 outline-none" step="0.1" />
                      </div>
                    </div>

                    <div className="flex items-center gap-2">
                        <input type="checkbox" id="ratio" checked={selectedImage.maintainAspectRatio} 
                               onChange={(e) => updateSelectedImage({ maintainAspectRatio: e.target.checked })} 
                               className="rounded text-blue-600 focus:ring-blue-500 w-4 h-4" />
                        <label htmlFor="ratio" className="text-sm text-gray-600 select-none cursor-pointer">Пропорции</label>
                    </div>
                  </div>
                ) : (
                    <div className="text-center text-sm text-gray-400 py-4 border rounded border-gray-100">
                        Нет выбранного изображения
                    </div>
                )}
                
                {/* Общие настройки */}
                <div className="space-y-2 mt-2">
                     <div className="flex items-center gap-2">
                       <input type="checkbox" id="grid" checked={showGrid} onChange={(e) => setShowGrid(e.target.checked)} className="rounded text-blue-600 w-4 h-4" />
                       <label htmlFor="grid" className="text-sm text-gray-600 cursor-pointer">Сетка 10x10 мм</label>
                    </div>
                    <div className="flex items-center gap-2">
                       <input type="checkbox" id="snap" checked={isSnapping} onChange={(e) => setIsSnapping(e.target.checked)} className="rounded text-blue-600 w-4 h-4" />
                       <label htmlFor="snap" className="text-sm text-gray-600 cursor-pointer flex items-center gap-1">
                          <Magnet className="w-3 h-3" /> Магнит к сетке
                       </label>
                    </div>
                </div>

                <div className="mt-auto">
                  <div className="bg-yellow-50 border border-yellow-200 rounded p-3 mb-4 text-xs text-yellow-800 shadow-sm">
                     <span className="font-bold">Печать:</span> A4, Масштаб 100%, Без полей.
                  </div>
                  <button onClick={handlePrint} disabled={!images.length || !isPrinterConnected} className={`w-full py-3 rounded-lg font-bold text-white shadow-lg transition-all flex items-center justify-center gap-2 ${(!images.length || !isPrinterConnected) ? 'bg-gray-400 cursor-not-allowed opacity-70' : 'bg-blue-600 hover:bg-blue-700 active:scale-95 shadow-blue-200'}`}>
                    <Printer className="w-5 h-5" /> Печать
                  </button>
                </div>
              </div>

              {/* Рабочая область */}
              <div className="flex-1 bg-gray-200 overflow-auto flex items-center justify-center p-4 md:p-8 relative print:p-0 print:bg-white print:block"
                   onMouseDown={() => setSelectedId(null)} /* Клик по фону снимает выделение */
              >
                <div id="printable-area" ref={paperRef} className="bg-white shadow-2xl relative overflow-hidden mx-auto print:shadow-none" style={{ width: '210mm', height: '297mm', minWidth: '210mm', minHeight: '297mm' }}>
                  
                  {showGrid && (
                    <div className="absolute inset-0 pointer-events-none opacity-20 no-print" style={{ backgroundImage: 'linear-gradient(#000 1px, transparent 1px), linear-gradient(90deg, #000 1px, transparent 1px)', backgroundSize: '10mm 10mm' }}></div>
                  )}

                  <div className="absolute bottom-2 right-2 text-gray-300 text-xs font-mono no-print pointer-events-none select-none">A4 (210mm x 297mm)</div>

                  {images.length === 0 && (
                    <div className="absolute inset-0 flex items-center justify-center text-gray-300 pointer-events-none no-print select-none">
                      <div className="text-center">
                        <Upload className="w-20 h-20 mx-auto mb-4 opacity-30" />
                        <p className="text-lg font-medium">Добавьте изображения</p>
                      </div>
                    </div>
                  )}

                  {images.map((img) => {
                     const isSelected = img.id === selectedId;
                     // Проверка выхода за границы для конкретного фото
                     const isImgOut = img.x < 0 || img.y < 0 || (img.x + img.width) > A4_WIDTH_MM || (img.y + img.height) > A4_HEIGHT_MM;
                     
                     return (
                        <div
                          key={img.id}
                          onMouseDown={(e) => handleMouseDown(e, img.id)}
                          onTouchStart={(e) => handleTouchStart(e, img.id)}
                          className={`absolute cursor-move group no-print-outline transition-shadow duration-75
                            ${isSelected ? 'outline outline-2 outline-blue-500 z-50' : 'z-10 hover:outline hover:outline-1 hover:outline-blue-300'}
                            ${isImgOut ? 'outline outline-2 outline-red-500' : ''}
                          `}
                          style={{
                            left: `${img.x}mm`,
                            top: `${img.y}mm`,
                            width: `${img.width}mm`,
                            height: `${img.height}mm`,
                            backgroundImage: `url(${img.src})`,
                            backgroundSize: '100% 100%',
                            backgroundRepeat: 'no-repeat',
                            touchAction: 'none'
                          }}
                        >
                          {/* Предупреждение о выходе (только если выделен или сильно вылазит) */}
                          {isImgOut && isSelected && (
                            <div className="absolute -top-6 right-0 text-xs bg-red-500 text-white px-2 py-0.5 rounded shadow no-print whitespace-nowrap z-50 font-bold flex items-center gap-1">
                               <AlertTriangle className="w-3 h-3" /> Вне границ!
                            </div>
                          )}

                          {/* Иконка перетаскивания (только при наведении или выборе) */}
                          <div className={`absolute inset-0 flex items-center justify-center pointer-events-none no-print transition-opacity duration-300 ${isSelected || 'opacity-0 group-hover:opacity-30'} ${isSelected ? 'opacity-20' : ''}`}>
                            <Move className="text-white drop-shadow-md w-12 h-12 bg-black/20 rounded-full p-2" />
                          </div>
                        </div>
                     );
                  })}
                </div>
              </div>
            </div>
          );
        }

        const container = document.getElementById('root');
        const root = ReactDOMClient.createRoot(container);
        root.render(<App />);
    </script>
</body>
</html>